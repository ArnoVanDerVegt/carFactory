; Wheel, copyright (c) 2020 - present by Arno van der Vegt
; Distributed under an MIT

#include "lib/modules/motor.whl"
#include "lib/modules/sensor.whl"
#include "lib/modules/standard.whl"

#define NO_MOVE    0xFFFF
#define HAND_OPEN  0x0000
#define HAND_CLOSE 0x0001
#define HAND_STOP  0x0002

#define ROBOT0 0
#define ROBOT1 1
#define ROBOT2 2
#define ROBOT3 3

#define ROBOT_REV -1
#define ROBOT_FWD 1

record ReadyBits
    number layer
    number bits
end

record RobotMotor
    number resetDir
    number layer
    number port
    number sensorLayer
    number sensorPort
end

record RobotConfig
    RobotMotor motor0
    RobotMotor motor1
    RobotMotor motor2
    RobotMotor motor3
    ReadyBits  readyBits0
    ReadyBits  readyBits1
    number     turnReset
union
    RobotMotor motors[4]
    ReadyBits  readyBitsA
    ReadyBits  readyBitsB
    number     turnResetA
end

object Robot
    RobotConfig robotConfig
    number      isReady
    number      isFinished
end

proc Robot.init()
end

proc Robot.motorIsReady()
    isReady = FALSE
    with robotConfig
        if motorLayerReadyBits(readyBits0.layer, readyBits0.bits) and motorLayerReadyBits(readyBits1.layer, readyBits1.bits)
            isReady = TRUE
        end
    end
end

proc Robot.motorWait()
    repeat
        motorIsReady()
        if isReady
            break
        end
    end
end

proc Robot.moveTo(number speed, number a, number b, number c, number d)
    number i

    for i = 0 to 2
        with robotConfig.motors[i]
            motorLayerSetSpeed(layer, port, speed)
        end
    end

    if a != NO_MOVE
        with robotConfig.motor0
            motorLayerMoveTo(layer, port, a)
        end
    end
    if b != NO_MOVE
        with robotConfig.motor1
            motorLayerMoveTo(layer, port, b)
        end
    end
    if c != NO_MOVE
        with robotConfig.motor2
            motorLayerMoveTo(layer, port, c)
        end
    end
    if d == NO_MOVE
        ret
    end
    with robotConfig.motor3
        select d
            case HAND_OPEN:
                motorLayerSetSpeed(layer, port, speed)
                motorLayerOn(layer, port)
                sleep(750)
                motorLayerStop(layer, port)
            case HAND_CLOSE:
                motorLayerSetSpeed(layer, port, speed)
                motorLayerOn(layer, port)
            case HAND_STOP:
                motorLayerStop(layer, port)
        end
    end
end

proc Robot.motorsZero()
    number i

    for i = 0 to 2
        with robotConfig.motors[i]
            motorLayerReset(layer, port)
        end
    end
end

proc Robot.beforeResetMotors()
    number i
    number speeds[3] = [-99, -50, -50]

    for i = 0 to 2
        with robotConfig.motors[i]
            motorLayerSetSpeed(layer, port, resetDir * speeds[i])
            motorLayerThreshold(layer, port, 50)
            motorLayerOn(layer, port)
        end
    end

    sleep(500)

    for i = 0 to 2
        with robotConfig.motors[i]
            motorLayerStop(layer, port)
        end
    end
end

proc Robot.resetMotors()
    number motor0Ready = FALSE ; Turn table
    number motor1Ready = FALSE ; Lower arm
    number motor2Ready = FALSE ; Upper arm
    number i

    number speeds[3] = [99, 50, 50]

    for i = 0 to 2
        with robotConfig.motors[i]
            motorLayerSetSpeed(layer, port, resetDir * speeds[i])
            motorLayerOn(layer, port)
        end
    end

    repeat
        with robotConfig.motor0
            if not motor0Ready and sensorLayerRead(sensorLayer, sensorPort) == COLOR_WHITE
                motorLayerStop(layer, port)
                motor0Ready = TRUE
            end
        end
        with robotConfig.motor1
            if not motor1Ready and sensorLayerRead(sensorLayer, sensorPort) == COLOR_WHITE
                motorLayerStop(layer, port)
                motor1Ready = TRUE
            end
        end
        with robotConfig.motor2
            if not motor2Ready and sensorLayerRead(sensorLayer, sensorPort) == COLOR_WHITE
                motorLayerStop(layer, port)
                motor2Ready = TRUE
            end
        end
        if motor0Ready and motor1Ready and motor2Ready
            break
        end
    end

    speeds = [-30, -20, -20]
    for i = 0 to 2
        with robotConfig.motors[i]
            motorLayerSetSpeed(layer, port, resetDir * speeds[i])
            motorLayerOn(layer, port)
            repeat
                if sensorLayerRead(sensorLayer, sensorPort) == COLOR_BLACK
                    motorLayerStop(layer, port)
                    break
                end
            end
        end
    end
end

proc Robot.reset()
    beforeResetMotors()
    resetMotors()
    motorsZero()
    moveTo(50, robotConfig.turnReset, NO_MOVE, NO_MOVE, NO_MOVE)
    motorWait()
    sleep(50)
    motorsZero()
end

proc Robot.rev(number motor)
    with robotConfig.motors[motor]
        motorLayerSetSpeed(layer, port, 50)
        motorLayerOn(layer, port)
    end
end

proc Robot.fwd(number motor)
    with robotConfig.motors[motor]
        motorLayerSetSpeed(layer, port, -50)
        motorLayerOn(layer, port)
    end
end

proc Robot.stop(number motor)
    with robotConfig.motors[motor]
        motorLayerStop(layer, port)
    end
end

proc Robot.stopAll()
    number i

    for i = 0 to 3
        with robotConfig.motors[i]
            if layer != -1
                motorLayerStop(layer, port)
            end
        end
    end
end
